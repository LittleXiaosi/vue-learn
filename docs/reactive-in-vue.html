<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue里面的响应式实现 | vue-learn</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/vue-learn/assets/css/0.styles.d467352b.css" as="style"><link rel="preload" href="/vue-learn/assets/js/app.fd4b1534.js" as="script"><link rel="preload" href="/vue-learn/assets/js/2.98137049.js" as="script"><link rel="preload" href="/vue-learn/assets/js/4.8ded4e39.js" as="script"><link rel="prefetch" href="/vue-learn/assets/js/3.af2f3518.js"><link rel="prefetch" href="/vue-learn/assets/js/5.c90b2ea4.js"><link rel="prefetch" href="/vue-learn/assets/js/6.7f201d43.js"><link rel="prefetch" href="/vue-learn/assets/js/7.97760cdd.js">
    <link rel="stylesheet" href="/vue-learn/assets/css/0.styles.d467352b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vue-learn/" class="home-link router-link-active"><!----> <span class="site-name">vue-learn</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/vue-learn/" class="sidebar-link">快速理解Vue的响应式</a></li><li><a href="/vue-learn/reactive-in-vue.html" class="active sidebar-link">Vue里面的响应式实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-learn/reactive-in-vue.html#基本流程" class="sidebar-link">基本流程</a></li><li class="sidebar-sub-header"><a href="/vue-learn/reactive-in-vue.html#详细讲解" class="sidebar-link">详细讲解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-learn/reactive-in-vue.html#src-core-instance" class="sidebar-link">src/core/instance</a></li><li class="sidebar-sub-header"><a href="/vue-learn/reactive-in-vue.html#src-platforms-web-runtime" class="sidebar-link">src/platforms/web/runtime/</a></li><li class="sidebar-sub-header"><a href="/vue-learn/reactive-in-vue.html#src-core-instance-2" class="sidebar-link">src/core/instance/</a></li></ul></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue里面的响应式实现"><a href="#vue里面的响应式实现" class="header-anchor">#</a> Vue里面的响应式实现</h1> <p>​		如果直接看Vue源码是如何实现响应式，是比较不容易理解的，主要是源码真的是有点绕，多个文件调来调去，所以我这边整理了一下流程：</p> <h2 id="基本流程"><a href="#基本流程" class="header-anchor">#</a> 基本流程</h2> <p>涉及到的文件：</p> <ul><li><a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/index.js" target="_blank" rel="noopener noreferrer">/src/core/instance/index.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/init.js" target="_blank" rel="noopener noreferrer">/src/core/instance/init.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js" target="_blank" rel="noopener noreferrer">/src/core/instance/state.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js" target="_blank" rel="noopener noreferrer">/src/core/observer/index.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/watcher.js" target="_blank" rel="noopener noreferrer">/src/core/observer/watcher.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/dep.js" target="_blank" rel="noopener noreferrer">/src/core/observer/dep.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/vuejs/vue/blob/dev/src/core/lifecycle.js" target="_blank" rel="noopener noreferrer">/src/core/lifecycle.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/vuejs/vue/blob/dev/src/platforms/web/runtime/index.js" target="_blank" rel="noopener noreferrer">/src/platforms/web/runtime/index.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> （PS：这个文件和Vue版本有关，默认webpack打包并且是Web环境，会执行这个文件）</li></ul> <p><img src="/vue-learn/assets/img/vue-reactive.74ddb35f.jpg" alt="vue-reactive"></p> <p>这张图里面基本包含了Vue响应式的所有主要函数，其实从图上看来，还是比较复杂的，接下来我会分区域逐步讲解这个图片上都做了什么。</p> <h2 id="详细讲解"><a href="#详细讲解" class="header-anchor">#</a> 详细讲解</h2> <h3 id="src-core-instance"><a href="#src-core-instance" class="header-anchor">#</a> src/core/instance</h3> <p>这个部分是Vue开始初始化的时候就需要执行的代码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//index.js</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_init</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>
</code></pre></div><p>这段代码传参开始进入Vue的初始化阶段</p> <blockquote><p>Vue的初始化是执行init函数，但是执行完init函数并没有完成响应式化，因为Vue是在$mount的时候（即挂载）时，才会执行watcher的初始化。所以真正的响应式必须要是一个被挂载的组件上才能体现。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//init.js</span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_init</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">options<span class="token operator">?</span><span class="token punctuation">:</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> vm<span class="token punctuation">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span>
 		<span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这是真正开始执行init函数定义的地方，注意这里的vm的数据类型是Component</p> <blockquote><p>vm是Vue的实例化，但其实vm的数据类型是Component，<code>const vm: Component = this</code>，也就是说本质上，Vue实例化的过程，就是创建组件的过程，但是正如第一点说的，只是初始化了组件并不完整，最终组件是需要挂载$mount来完成响应式。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//state.js</span>
<span class="token function">initData</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
</code></pre></div><p>开始执行初始化data，<code>state.js</code>内其实需要处理所有能够被<code>this.</code>找到的东西，包括props，methods，data，computed，watch。</p> <blockquote><ol><li>Vue在初始化的时候，data能够接受一个函数返回值的原因就是因为在initData的时候，如果<code>typeof vm.$options.data===‘’function“</code>的值为true的时候，会执行一次这个data函数获取返回值</li> <li>初始化顺序是 props-&gt;methods-&gt;data-&gt;computed-&gt;watch，所以在data函数中，可以访问props参数，在computed可以访问data数据，watch监听所有，是因为数据初始化顺序</li></ol></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//state.js</span>
<span class="token keyword">let</span> data <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>data
<span class="token operator">...</span>
<span class="token function">proxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">_data</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>
<span class="token operator">...</span>
<span class="token function">observe</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* asRootData */</span><span class="token punctuation">)</span>
</code></pre></div><p>拿到data参数之后，通过observe方法开始给data内的数据添加响应式处理。</p> <blockquote><ol><li>props也需要响应式化，但是流程比较data相对简单点，核心方法一样</li> <li>这里的proxy不是对数据响应式的那个Proxy，而是处理this指针指向的问题，通过<code>Object.defineProperty(vm, key, sharedPropertyDefinition)</code>方法，把对vm.xxx的访问代理成了vm._data.xxx的访问。从而实现了Vue内部可以使用this.xxx来访问数据。</li></ol></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//init.js</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在初始化执行完毕之后（所有的init执行完），如果当前的参数里面有el的话，就会执行挂载</p> <blockquote><p>Vue的watcher实例化是在这个阶段，响应式需要真正跑起来，还记得watcher内的函数是需要被执行一次收集依赖的么？Vue就是在这个时候收集依赖的。不过过程稍微复杂一点</p></blockquote> <h3 id="src-platforms-web-runtime"><a href="#src-platforms-web-runtime" class="header-anchor">#</a> src/platforms/web/runtime/</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//index.js</span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$mount</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token operator">...</span>
	<span class="token keyword">return</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> el<span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里提供了一个通用的挂载方法，实际上是执行了<code>mountComponent</code>函数</p> <blockquote><p>这里需要注意的是，Vue根据引用版本不同，当前的runtime内执行的文件是不一样的，默认的浏览器版本Vue才是这个文件，Weex和本地编译，都不是这个文件。</p></blockquote> <h3 id="src-core-instance-2"><a href="#src-core-instance-2" class="header-anchor">#</a> src/core/instance/</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//lifecycle.js</span>
  <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> updateComponent<span class="token punctuation">,</span> noop<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">before</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_isMounted <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vm<span class="token punctuation">.</span>_isDestroyed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeUpdate'</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* isRenderWatcher */</span><span class="token punctuation">)</span>
</code></pre></div><p>这里才是真正初始化了Watcher，执行了内部的计算函数。这几个参数稍微讲解下</p> <ul><li>vm：当前的Vue实例（也就是当前组件）</li> <li>updateComponent：计算函数，用来计算组件内各个数据的值，每次Vue的数据变化，其实就是需要重新触发这个函数的计算，从而实现响应式的数据更新。这个函数内部有点复杂，之后聊到组件实现细节再提好了。</li> <li>noop：回调函数，计算完数据更新之后的回调函数。我们在Vue中写的Watch内的回调，就是在这里被执行了</li> <li>before：钩子函数，数据更新之前会执行</li> <li>true：是不是一个renderWatcher，如果是一个渲染watcher，会有个单独的指针提供访问，其余的watchers里面，其实是不涉及到重新render的，执行时机就不一样了。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//lifecycle.js</span>
<span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里就是执行数据的重新计算函数，本质上会接受两个参数</p> <ul><li>vm._render()：返回值是一个Vnode，用来重新渲染页面</li> <li>hydrating：状态位，用来判断是不是第一次渲染（计算量不同）</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//lifecycle.js</span>
vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">__patch__</span><span class="token punctuation">(</span>prevVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
</code></pre></div><p>在这个地方，处理真正的渲染成HTML节点并且挂在对应的真实dom上面。</p> <p>执行完所有的这一切，第一次生命周期就结束了。这里会返回一个VM，然后我们重新回到响应式内部看看代码，因为Watcher虽然初始化完了，但是我们的<code>updateComponent</code>只执行完了第一次计算，之后的计算就要回到响应式来触发了。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vue-learn/" class="prev router-link-active">快速理解Vue的响应式</a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/vue-learn/assets/js/app.fd4b1534.js" defer></script><script src="/vue-learn/assets/js/2.98137049.js" defer></script><script src="/vue-learn/assets/js/4.8ded4e39.js" defer></script>
  </body>
</html>
