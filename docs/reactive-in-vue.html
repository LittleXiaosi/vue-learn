<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue里面的响应式实现 | vue-learn</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/vue-learn/assets/css/0.styles.d467352b.css" as="style"><link rel="preload" href="/vue-learn/assets/js/app.b1f163e8.js" as="script"><link rel="preload" href="/vue-learn/assets/js/2.98137049.js" as="script"><link rel="preload" href="/vue-learn/assets/js/4.b26b7bc9.js" as="script"><link rel="prefetch" href="/vue-learn/assets/js/3.a9f5a444.js"><link rel="prefetch" href="/vue-learn/assets/js/5.c90b2ea4.js"><link rel="prefetch" href="/vue-learn/assets/js/6.a98a30d6.js"><link rel="prefetch" href="/vue-learn/assets/js/7.9eaf6626.js"><link rel="prefetch" href="/vue-learn/assets/js/8.1445ac92.js"><link rel="prefetch" href="/vue-learn/assets/js/9.6613c730.js">
    <link rel="stylesheet" href="/vue-learn/assets/css/0.styles.d467352b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vue-learn/" class="home-link router-link-active"><!----> <span class="site-name">vue-learn</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/vue-learn/" class="sidebar-link">快速理解Vue的响应式</a></li><li><a href="/vue-learn/reactive-in-vue.html" class="active sidebar-link">Vue里面的响应式实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-learn/reactive-in-vue.html#基本流程" class="sidebar-link">基本流程</a></li><li class="sidebar-sub-header"><a href="/vue-learn/reactive-in-vue.html#详细讲解" class="sidebar-link">详细讲解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-learn/reactive-in-vue.html#src-core-instance" class="sidebar-link">src/core/instance</a></li><li class="sidebar-sub-header"><a href="/vue-learn/reactive-in-vue.html#src-platforms-web-runtime" class="sidebar-link">src/platforms/web/runtime/</a></li><li class="sidebar-sub-header"><a href="/vue-learn/reactive-in-vue.html#src-core-instance-2" class="sidebar-link">src/core/instance/</a></li><li class="sidebar-sub-header"><a href="/vue-learn/reactive-in-vue.html#src-core-observer" class="sidebar-link">src/core/observer/</a></li></ul></li></ul></li><li><a href="/vue-learn/compile-render.html" class="sidebar-link">Vue的组件编译</a></li><li><a href="/vue-learn/mounting-process.html" class="sidebar-link">Vue的组件挂载</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue里面的响应式实现"><a href="#vue里面的响应式实现" class="header-anchor">#</a> Vue里面的响应式实现</h1> <p>​		如果直接看Vue源码是如何实现响应式，是比较不容易理解的，主要是源码真的是有点绕，多个文件调来调去，所以我这边整理了一下流程：</p> <h2 id="基本流程"><a href="#基本流程" class="header-anchor">#</a> 基本流程</h2> <p>涉及到的文件：</p> <ul><li><a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/index.js" target="_blank" rel="noopener noreferrer">/src/core/instance/index.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/init.js" target="_blank" rel="noopener noreferrer">/src/core/instance/init.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js" target="_blank" rel="noopener noreferrer">/src/core/instance/state.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js" target="_blank" rel="noopener noreferrer">/src/core/observer/index.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/watcher.js" target="_blank" rel="noopener noreferrer">/src/core/observer/watcher.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/dep.js" target="_blank" rel="noopener noreferrer">/src/core/observer/dep.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/vuejs/vue/blob/dev/src/core/lifecycle.js" target="_blank" rel="noopener noreferrer">/src/core/lifecycle.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/vuejs/vue/blob/dev/src/platforms/web/runtime/index.js" target="_blank" rel="noopener noreferrer">/src/platforms/web/runtime/index.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> （PS：这个文件和Vue版本有关，默认webpack打包并且是Web环境，会执行这个文件）</li></ul> <p><img src="/vue-learn/assets/img/vue-reactive.74ddb35f.jpg" alt="vue-reactive"></p> <p>这张图里面基本包含了Vue响应式的所有主要函数，其实从图上看来，还是比较复杂的，接下来我会分区域逐步讲解这个图片上都做了什么。</p> <h2 id="详细讲解"><a href="#详细讲解" class="header-anchor">#</a> 详细讲解</h2> <h3 id="src-core-instance"><a href="#src-core-instance" class="header-anchor">#</a> src/core/instance</h3> <p>这个部分是Vue开始初始化的时候就需要执行的代码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//index.js</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_init</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>
</code></pre></div><p>这段代码传参开始进入Vue的初始化阶段</p> <blockquote><p>Vue的初始化是执行init函数，但是执行完init函数并没有完成响应式化，因为Vue是在$mount的时候（即挂载）时，才会执行watcher的初始化。所以真正的响应式必须要是一个被挂载的组件上才能体现。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//init.js</span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_init</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">options<span class="token operator">?</span><span class="token punctuation">:</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> vm<span class="token punctuation">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span>
 		<span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这是真正开始执行init函数定义的地方，注意这里的vm的数据类型是Component</p> <blockquote><p>vm是Vue的实例化，但其实vm的数据类型是Component，<code>const vm: Component = this</code>，也就是说本质上，Vue实例化的过程，就是创建组件的过程，但是正如第一点说的，只是初始化了组件并不完整，最终组件是需要挂载$mount来完成响应式。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//state.js</span>
<span class="token function">initData</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
</code></pre></div><p>开始执行初始化data，<code>state.js</code>内其实需要处理所有能够被<code>this.</code>找到的东西，包括props，methods，data，computed，watch。</p> <blockquote><ol><li>Vue在初始化的时候，data能够接受一个函数返回值的原因就是因为在initData的时候，如果<code>typeof vm.$options.data===‘’function“</code>的值为true的时候，会执行一次这个data函数获取返回值</li> <li>初始化顺序是 props-&gt;methods-&gt;data-&gt;computed-&gt;watch，所以在data函数中，可以访问props参数，在computed可以访问data数据，watch监听所有，是因为数据初始化顺序</li></ol></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//state.js</span>
<span class="token keyword">let</span> data <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>data
<span class="token operator">...</span>
<span class="token function">proxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">_data</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>
<span class="token operator">...</span>
<span class="token function">observe</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* asRootData */</span><span class="token punctuation">)</span>		<span class="token comment">// go to src/core/observer/index.js</span>
</code></pre></div><p>拿到data参数之后，通过observe方法开始给data内的数据添加响应式处理。</p> <blockquote><ol><li>props也需要响应式化，但是流程比较data相对简单点，核心方法一样</li> <li>这里的proxy不是对数据响应式的那个Proxy，而是处理this指针指向的问题，通过<code>Object.defineProperty(vm, key, sharedPropertyDefinition)</code>方法，把对vm.xxx的访问代理成了vm._data.xxx的访问。从而实现了Vue内部可以使用this.xxx来访问数据。</li></ol></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//init.js</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在初始化执行完毕之后（所有的init执行完），如果当前的参数里面有el的话，就会执行挂载</p> <blockquote><p>Vue的watcher实例化是在这个阶段，响应式需要真正跑起来，还记得watcher内的函数是需要被执行一次收集依赖的么？Vue就是在这个时候收集依赖的。不过过程稍微复杂一点</p></blockquote> <h3 id="src-platforms-web-runtime"><a href="#src-platforms-web-runtime" class="header-anchor">#</a> src/platforms/web/runtime/</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//index.js</span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$mount</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token operator">...</span>
	<span class="token keyword">return</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> el<span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里提供了一个通用的挂载方法，实际上是执行了<code>mountComponent</code>函数</p> <blockquote><p>这里需要注意的是，Vue根据引用版本不同，当前的runtime内执行的文件是不一样的，默认的浏览器版本Vue才是这个文件，Weex和本地编译，都不是这个文件。</p></blockquote> <h3 id="src-core-instance-2"><a href="#src-core-instance-2" class="header-anchor">#</a> src/core/instance/</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//lifecycle.js</span>
  <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> updateComponent<span class="token punctuation">,</span> noop<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">before</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_isMounted <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vm<span class="token punctuation">.</span>_isDestroyed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeUpdate'</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* isRenderWatcher */</span><span class="token punctuation">)</span>
</code></pre></div><p>这里才是真正初始化了Watcher，执行了内部的计算函数。这几个参数稍微讲解下</p> <ul><li>vm：当前的Vue实例（也就是当前组件）</li> <li>updateComponent：计算函数，用来计算组件内各个数据的值，每次Vue的数据变化，其实就是需要重新触发这个函数的计算，从而实现响应式的数据更新。这个函数内部在<a href="/vue-learn/mounting-process.html">Vue的组件挂载</a>有详细说明</li> <li>noop：回调函数，计算完数据更新之后的回调函数。我们在Vue中写的Watch内的回调，就是在这里被执行了</li> <li>before：钩子函数，数据更新之前会执行</li> <li>true：是不是一个renderWatcher，如果是一个渲染watcher，会有个单独的指针提供访问，其余的watchers里面，其实是不涉及到重新render的，执行时机就不一样了。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//lifecycle.js</span>
<span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里就是执行数据的重新计算函数，本质上会接受两个参数（详细说明请看<a href="/vue-learn/mounting-process.html">Vue的组件挂载</a>）</p> <ul><li>vm._render()：返回值是一个Vnode，用来重新渲染页面，而在执行render函数的时候，就会把render函数内定义的所有prop和data访问一遍，也就是在这个时候，完成了所有的data和prop的响应式收集触发。</li> <li>hydrating：状态位，用来判断是不是第一次渲染（计算量不同）</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//lifecycle.js</span>
vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">__patch__</span><span class="token punctuation">(</span>prevVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
</code></pre></div><p>在这个地方，处理真正的渲染成HTML节点并且挂在对应的真实dom上面。</p> <p>执行完所有的这一切，第一次生命周期就结束了。这里会返回一个VM，然后我们重新回到响应式内部看看代码，因为Watcher虽然初始化完了，但是我们的<code>updateComponent</code>只执行完了第一次计算(其实已经完成了响应式收集)，之后的计算就要回到响应式来触发了。</p> <h3 id="src-core-observer"><a href="#src-core-observer" class="header-anchor">#</a> src/core/observer/</h3> <p>这部分相对比较复杂，这里面主要是响应式的定义代码，但是需要注意的是，这里面只是<strong>定义</strong>了响应式对象，真正要执行起来是需要new Watcher之后，getter和setter触发才行</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//index.js</span>
ob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>		<span class="token comment">// value === data</span>
</code></pre></div><p>初始化data响应式时候，代码执行顺序是从<code>src/core/instance/state.js</code>文件来的，所以当前的<code>value==data==vm.$options.data</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//index.js</span>
<span class="token keyword">const</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>					<span class="token comment">//obj==value</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里就是遍历data的属性，分别给每个属性添加响应式处理。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//index.js</span>
<span class="token operator">...</span>
<span class="token keyword">const</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">...</span>
<span class="token keyword">const</span> getter <span class="token operator">=</span> property <span class="token operator">&amp;&amp;</span> property<span class="token punctuation">.</span>get
<span class="token keyword">const</span> setter <span class="token operator">=</span> property <span class="token operator">&amp;&amp;</span> property<span class="token punctuation">.</span>set
<span class="token operator">...</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  	enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  	<span class="token function-variable function">get</span><span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">set</span><span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>     
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>执行到到这里，才是真正开始定义响应式数据，现在我们需要分别看一下get和set的处理</p> <blockquote><p>这里每一个dep其实对应的是每一个data内的属性，因为遍历的时候每次都要重新实例化新的dep</p></blockquote> <h4 id="get：depend"><a href="#get：depend" class="header-anchor">#</a> get：depend</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// index.js</span>
<span class="token function-variable function">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token function">reactiveGetter</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> value <span class="token operator">=</span> getter <span class="token operator">?</span> <span class="token function">getter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">:</span> val
      <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dep<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token operator">...</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> value
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><p>这里就是真正的data数据的get定义，在这里主要做的就是执行<code>dep.depend()</code>，也就是把对应的watcher添加到dep里面，dep会收集所有和当前属性相关的watcher，是一个数组；</p> <blockquote><p>这里面有个判断<code>Dep.target</code>，这个<code>target</code>值其实就是一个当前的<code>Watcher</code>，在初始化并且用户没有额外添加自己的watch的情况下，这个watcher就是<code>RenderWatcher</code>，所有的dep在初始化的时候都会添加同一个<code>RenderWatcher</code>。这是因为之前我们执行<code>$mount</code>的时候，执行了<code>new Watcher</code>，具体细节我们就需要从下面的<code>new Watcher</code>细节看起了</p></blockquote> <h4 id="set：notify"><a href="#set：notify" class="header-anchor">#</a> set：notify</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// index.js</span>
<span class="token function-variable function">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token function">reactiveSetter</span> <span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> value <span class="token operator">=</span> getter <span class="token operator">?</span> <span class="token function">getter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">:</span> val
  <span class="token comment">/* eslint-disable no-self-compare */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>newVal <span class="token operator">===</span> value <span class="token operator">||</span> <span class="token punctuation">(</span>newVal <span class="token operator">!==</span> newVal <span class="token operator">&amp;&amp;</span> value <span class="token operator">!==</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
 <span class="token operator">...</span>
  <span class="token comment">// #7981: for accessor properties without setter</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>getter <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>setter<span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>setter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> newVal<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    val <span class="token operator">=</span> newVal
  <span class="token punctuation">}</span>
	<span class="token operator">...</span>
  dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里是真正的data的set定义，主要目的就是执行<code>dep.notify()</code>并且更新一下数据。这里有几个比较特别的地方，需要额外注意一下：</p> <ul><li><code>newVal === value</code>：这里判断了新旧数据，所以只有在新旧数据不同的时候，才会执行watcher的计算，所以Vue的Watcher本质上是一个差异更新。</li> <li><code>(newVal !== newVal &amp;&amp; value !== value)</code>：这里是判断<code>NaN===NaN</code>为false引起的bug</li> <li><code>setter.call</code>：用户可以自行改动setter来修改数据计算（但是比较少见这种处理）</li></ul> <h4 id="depend的执行"><a href="#depend的执行" class="header-anchor">#</a> depend的执行</h4> <p>好的，看完了set和get的定义，还记得我们的代码真正执行的地方是在new Watcher的时候么，我们现在回过头看一下，第一次执行new Watcher的时候，执行了什么？</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//watcher.js</span>
 <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lazy <span class="token operator">?</span> <span class="token keyword">undefined</span> <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p><code>watcher</code>在初始化之后，会执行一<code>this.get()</code>次获取<code>this.value</code>数据，而这个<code>this.value</code>就是当前<code>watcher</code>计算出来的值，</p> <blockquote><ol><li>而在当前的例子中，当前的<code>watcher</code>就是默认的<code>RenderWatcher</code>，这个<code>watcher</code>的<code>value</code>计算值是空的，没有返回值。</li> <li>如果<code>this.value</code>有值，那就是user watcher的计算的结果，就是我们监听的watcher的nv；</li></ol></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//watcher.js</span>
<span class="token keyword">get</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">pushTarget</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token keyword">let</span> value
  <span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vm
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token operator">...</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>deep<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">traverse</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">popTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cleanupDeps</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> value
<span class="token punctuation">}</span>
</code></pre></div><p>这里就是执行了watcher的get，</p> <ul><li><code>pushTarget(this)，popTarget()</code>：这两个方法是把watcher添加进入dep里面，具体定义在<code>dep.js</code>里面</li> <li><code>value = this.getter.call(vm, vm)</code>：这里是执行了Watcher内的计算，得到新的的Value（或者只是触发依赖）对于渲染watcher而言，<code>this.getter</code>就是上文的<code>updateComponent</code>，<code>updateComponent</code>的内部我们先不深究，但是这个函数的执行，就会触发到所有的<code>data</code>内的属性的<code>get</code>。具体执行就是<code>dep.depend</code></li> <li><code>this.cleanupDeps()</code>：本质上是更新订阅（当然也会清除旧的订阅）不影响主要的逻辑，主要处理的是类似v-if的情况，避免额外的计算，保持依赖都是最新值。</li> <li><code>this.deep</code>：这个地方是处理对象监听的，具体细节请看Deep处理</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//dep.js</span>
Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token keyword">const</span> targetStack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">pushTarget</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">:</span> <span class="token operator">?</span>Watcher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  targetStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> target
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">popTarget</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  targetStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> targetStack<span class="token punctuation">[</span>targetStack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>还记得我们上面在get内需要判断 <code>Dep.target</code>么，就是在这里产生值的，在我们当前流程中，<code>target</code>就是<code>RenderWatcher</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//dep.js</span>
<span class="token function">depend</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Dep<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">addDep</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>					<span class="token comment">//Dep.target===watcher，this===dep</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里执行的就是<code>dep.depend</code>，所以本质上，还是执行了<code>watcher</code>的<code>addDep()</code>方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//watcher.js   from：dep.depend()  ==》  watcher.addDep(dep)</span>
<span class="token function">addDep</span> <span class="token punctuation">(</span><span class="token parameter">dep<span class="token punctuation">:</span> Dep</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> id <span class="token operator">=</span> dep<span class="token punctuation">.</span>id
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>newDepIds<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>newDepIds<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>newDeps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>depIds<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      dep<span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里有一段比较复杂的判断，主要是因为之前我们提到了<code>this.cleanupDeps</code>，所以每次的依赖都是重新收集的，每次<code>newDeps</code>都是新的，</p> <blockquote><p>这里把<code>dep</code>添加进了<code>watcher.deps</code>里面（<code>cleanupDeps</code>的时候，把<code>newDeps</code>赋值给了<code>deps</code>）</p></blockquote> <ul><li>初始化：初始化的时候，<code>newDepIds</code>和<code>depIds</code>都是空的，所以就直接执行了<code>dep.addSub(this)</code></li> <li>数据变化：<code>newDepIds</code>会保持最新收集到的状态，<code>depIds</code>会把缺少的那一个添加进入<code>dep</code></li></ul> <p>我们继续看<code>addSub</code>又发生了什么</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//dep.js from: dep.addSub(this) ==》 dep.addSub(watcher)</span>
<span class="token function">addSub</span> <span class="token punctuation">(</span><span class="token parameter">sub<span class="token punctuation">:</span> Watcher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>这里把<code>watcher</code>添加进入了<code>dep.subs</code>里面</p></blockquote> <p>所以这个地方需要稍微注意一下，我们在原理展示里面没有这么复杂，只需要subs收集watcher就可以了，但是Vue真实处理的时候是双向收集的，dep收集watcher，而watcher也收集dep。</p> <p>dep.subs收集watcher是因为任何一个属性的修改，都需要触发所有的计算。</p> <p>watcher.deps收集dep是因为任何的的重新计算，要触发对应回调函数。</p> <h4 id="notify的执行"><a href="#notify的执行" class="header-anchor">#</a> notify的执行</h4> <p>我们到目前为止已经完成了依赖收集的过程，现在我们再来看看派发过程是怎么处理的。在数据有修改的时候，实际上是触发了set的<code>notify()</code></p> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token comment">//dep.js.  from : dep.notify()</span>
<span class="token function">notify</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> subs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token operator">...</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> subs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>还记得<code>subs</code>里面放的都是<code>watcher</code>么？所以接下来又回到<code>watcher</code></p> <div class="language-JS extra-class"><pre class="language-js"><code><span class="token comment">//watcher.js   </span>
<span class="token function">update</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token operator">...</span>
   <span class="token function">queueWatcher</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>   
<span class="token punctuation">}</span>
</code></pre></div><p>接下来就到了另一个文件</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//scheduler.js</span>

<span class="token keyword">const</span> queue<span class="token punctuation">:</span> Array<span class="token operator">&lt;</span>Watcher<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> has<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>key<span class="token punctuation">:</span> number<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token operator">?</span><span class="token boolean">true</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> flushing <span class="token operator">=</span> <span class="token boolean">false</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">queueWatcher</span> <span class="token punctuation">(</span><span class="token parameter">watcher<span class="token punctuation">:</span> Watcher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> id <span class="token operator">=</span> watcher<span class="token punctuation">.</span>id
  <span class="token keyword">if</span> <span class="token punctuation">(</span>has<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    has<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flushing<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>watcher<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> i <span class="token operator">=</span> queue<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> index <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id <span class="token operator">&gt;</span> watcher<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        i<span class="token operator">--</span>
      <span class="token punctuation">}</span>
      queue<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> watcher<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// queue the flush</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>waiting<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      waiting <span class="token operator">=</span> <span class="token boolean">true</span>
      <span class="token operator">...</span>
      <span class="token function">nextTick</span><span class="token punctuation">(</span>flushSchedulerQueue<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里有几个比较复杂的注意项：</p> <ul><li><code>has[id]</code>：这个判断是为了保证，一个<code>watcher</code>对象被添加一次。举个例子，我们一个组件只有一个<code>renderWatcher</code>，这一个<code>RenderWatcher</code>在组件内<code>data</code>在多处修改时，应该只需要计算一次。</li> <li><code>flushing</code>：状态值，当前是否正在进行<code>watcher</code>的计算，这个地方如果为<code>false</code>，说明正在计算，新增加的<code>watcher</code>会经过排序，插入到<code>queue</code>里面</li> <li><code>queue</code>：存储所有需要计算的watcher</li> <li><code>nextTick</code>：下一个<code>tick</code>再执行这些<code>watcher</code>，默认情况下，执行的就是异步刷新</li></ul> <div class="language-JS extra-class"><pre class="language-js"><code><span class="token comment">//scheduler.js </span>

<span class="token keyword">function</span> <span class="token function">flushSchedulerQueue</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  currentFlushTimestamp <span class="token operator">=</span> <span class="token function">getNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  flushing <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token keyword">let</span> watcher<span class="token punctuation">,</span> id

  queue<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a<span class="token punctuation">.</span>id <span class="token operator">-</span> b<span class="token punctuation">.</span>id<span class="token punctuation">)</span>

  <span class="token comment">// do not cache length because more watchers might be pushed</span>
  <span class="token comment">// as we run existing watchers</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    watcher <span class="token operator">=</span> queue<span class="token punctuation">[</span>index<span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">.</span>before<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      watcher<span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    id <span class="token operator">=</span> watcher<span class="token punctuation">.</span>id
    has<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span>
    watcher<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span>
	<span class="token operator">...</span>
  <span class="token function">resetSchedulerState</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里就是执行对于queue进行遍历，中间有几点比较值得注意</p> <ul><li><code>queue.sort</code>：不论是这个阶段，还是之前插入阶段，watcher的排序都是保证从小到大的，这是因为</li> <li>组件渲染是先父后子，所以id小的是父组件，prop传参也是从父到子，watcher计算顺序需要与数据流动顺序保持一致，不然可能导致子组件的响应式计算值是有问题的。</li> <li><code>RenderWatcher</code>是在<code>$mount</code>阶段实例化的，但是<code>UserWatcher</code>是在<code>initWatcher</code>阶段产生的，所以<code>UserWatcher</code>的<code>id</code>会比<code>RenderWatcher</code>小，优先计算<code>UserWatcher</code>也是为了保证<code>RenderWatcher</code>计算出来的最终渲染数据正确</li> <li>如果一个组件在父组件执行阶段被销毁了，这个组件下的所有watcher的active属性就会被设置为false，之后的watcher都不会再进行计算了</li> <li><code>watcher.before()</code>：在<code>new Watcher</code>的时候，传入的参数，默认的<code>RenderWatcher</code>会有这个参数，是<code>beforeUpdate</code>钩子函数</li> <li><code>has[id] = null</code>，  <code>resetSchedulerState()</code>：清除当前这个tick里面的所有的需要计算的watcher，所以当下次数据变化的时候，所有的watcher又是新的一轮了。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// watcher.js		from:watcher.run()</span>
  <span class="token function">run</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>active<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">!==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">||</span><span class="token function">isObject</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">||</span><span class="token keyword">this</span><span class="token punctuation">.</span>deep<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// set new value</span>
        <span class="token keyword">const</span> oldValue <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cb</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">,</span> value<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span>
          <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">handleError</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">callback for watcher &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>expression<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cb</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">,</span> value<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

</code></pre></div><p>这里就是最终更新数据的地方，在执行了<code>this.get()</code>的时候，其实就执行了数据的更新，然后再执行回调函数，我们写的watch就是在这个地方触发的回调。</p> <h4 id="deep处理"><a href="#deep处理" class="header-anchor">#</a> deep处理</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//watcher.js</span>
  <span class="token keyword">get</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
  <span class="token function">traverse</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
	<span class="token operator">...</span>
  <span class="token keyword">return</span> value
<span class="token punctuation">}</span>
</code></pre></div><p>另外这里有个需要注意的地方就是<code>deep watch</code>的处理，在不添加deep的时候，对象深层改动是不能检测到的，这是因为现行版本的检测是<code>defineProperty</code>，所以是只能检测属性的修改，所以在对<code>obj.a</code>的数据进行修改的时候，只会触发<code>obj.a</code>的<code>set</code>，而不会触发obj的<code>set</code>（这一点，和Proxy代理是不一样的）。所以<code>obj</code>的<code>watcher</code>是检测不到属性的修改的。而<code>traverse(value)</code>这个方法就是去读取一次内部参数，触发这些参数的<code>get</code>，然后把<code>obj</code>收集的<code>subs</code>里面添加上子属性的<code>watcher</code>，这样就可以触发对应的watcher了</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vue-learn/" class="prev router-link-active">快速理解Vue的响应式</a></span> <span class="next"><a href="/vue-learn/compile-render.html">Vue的组件编译</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/vue-learn/assets/js/app.b1f163e8.js" defer></script><script src="/vue-learn/assets/js/2.98137049.js" defer></script><script src="/vue-learn/assets/js/4.b26b7bc9.js" defer></script>
  </body>
</html>
