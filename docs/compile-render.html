<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue的组件编译 | vue-learn</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/vue-learn/assets/css/0.styles.d467352b.css" as="style"><link rel="preload" href="/vue-learn/assets/js/app.06b834f0.js" as="script"><link rel="preload" href="/vue-learn/assets/js/2.98137049.js" as="script"><link rel="preload" href="/vue-learn/assets/js/7.f958185c.js" as="script"><link rel="prefetch" href="/vue-learn/assets/js/3.ae97eef9.js"><link rel="prefetch" href="/vue-learn/assets/js/4.6bdd0248.js"><link rel="prefetch" href="/vue-learn/assets/js/5.c90b2ea4.js"><link rel="prefetch" href="/vue-learn/assets/js/6.a98a30d6.js"><link rel="prefetch" href="/vue-learn/assets/js/8.f731ac16.js">
    <link rel="stylesheet" href="/vue-learn/assets/css/0.styles.d467352b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vue-learn/" class="home-link router-link-active"><!----> <span class="site-name">vue-learn</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/vue-learn/" class="sidebar-link">快速理解Vue的响应式</a></li><li><a href="/vue-learn/reactive-in-vue.html" class="sidebar-link">Vue里面的响应式实现</a></li><li><a href="/vue-learn/compile-render.html" class="active sidebar-link">Vue的组件编译</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-learn/compile-render.html#编译和渲染" class="sidebar-link">编译和渲染</a></li><li class="sidebar-sub-header"><a href="/vue-learn/compile-render.html#virtual-dom" class="sidebar-link">Virtual DOM</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue的组件编译"><a href="#vue的组件编译" class="header-anchor">#</a> Vue的组件编译</h1> <h2 id="编译和渲染"><a href="#编译和渲染" class="header-anchor">#</a> 编译和渲染</h2> <p>​	我们上一篇文章，聊了关于Vue的响应式数据的源码实现，接下来聊一聊，Vue的组件编译，Vue的组件编译，有两个步骤分别是：</p> <ul><li>编译（Compiler）：把Template模板转化问Render Function，执行环境包括<strong>服务器</strong>和<strong>浏览器</strong></li> <li>渲染（Render）：把Render Function执行得到Vnode，Vnode渲染成为真实DOM节点。执行环境只有<strong>浏览器</strong></li></ul> <p>另外一点值得注意的就是，如果我们在使用Vue Cli创建Vue项目的时候，会有一个<code>vue build</code>选项，这个选项会问你是需要创建：</p> <ul><li>Runtime+Compiler：32kb min+ gzip，支持网页编译<code>template</code>字符串。</li> <li>Runtime-only：22kb min+gzip，所有<code>template</code>以<code>.vue</code>文件的形式，在<code>webpack build</code>的阶段编译成<code>rende</code>r函数</li></ul> <p>两个不同的版本的核心区别就是<strong>编译</strong>阶段的时机，只有<code>Runtime+Compiler</code>版本才会使用<code>Template</code>参数，并且是在<code>render</code>函数不存在的时候，<code>Runtime-only</code>的编译是靠<code>webpack</code> 的 <code>vue-loader</code>，而不是靠Vue本身的编译体系，也就是说，使用<code>Runtime-only</code>的时候，编译已经完成，所有的<code>.vue</code>文件已经变成了对应的<code>render</code>函数。默认情况下，我们只需要使用<code>Runtime-only</code>版本就可以了。</p> <h2 id="virtual-dom"><a href="#virtual-dom" class="header-anchor">#</a> Virtual DOM</h2> <p>​		对比于<code>javascript</code>对象，原生<code>DOM</code>对象是非常庞大的。一个简单的<code>&lt;div&gt;</code>节点就拥有246个属性，如果直接操作<code>DOM</code>，开销是要比操作<code>javascript</code>对象大很多的。所以这也是为什么Vue需要有一个<code>Virtual DOM</code>，但是<code>Virtual DOM</code>并不是<code>Vue</code>特有的概念，很多前端框架，比如<code>React</code>，都使用了<code>Virtual DOM</code>这个概念。</p> <p>​		另一个需要使用<code>Virtual DOM</code>的原因是，我们可以把<code>Virtual DOM</code>视为一个数据蓝图，当我们需要修改某个数据的时候，其实可以先对比一下蓝图，然后再修改<strong>差异</strong>部分，这样也把<code>DOM</code>操作的开销降低不少。</p> <p>##渲染步骤与生命周期</p> <h4 id="渲染步骤"><a href="#渲染步骤" class="header-anchor">#</a> 渲染步骤</h4> <ol><li>Template--&gt;Render Function
<ul><li><code>.vue</code>文件就是<code>Template</code>，是在<code>webpack</code>编译阶段转为<code>Render Function</code></li></ul></li> <li>Render Function--&gt;Vnode
<ul><li><code>render function</code>的执行，就是在<code>updateComponent</code>函数执行阶段执行的（响应式原理里面提到了）</li> <li>如果我们手动写了<code>Render Function</code>，其实本质上就是直接跳过了编译阶段（第一步），直接使用我们自定义的<code>Render Function</code>开始第二步的渲染阶段。</li></ul></li> <li>Vnode--&gt;Browser
<ul><li>Vnode最后更新到Browser的时候，是差异更新的，不是全量替换</li></ul></li></ol> <h4 id="生命周期中的渲染"><a href="#生命周期中的渲染" class="header-anchor">#</a> 生命周期中的渲染</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//生命周期</span>

</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vue-learn/reactive-in-vue.html" class="prev">Vue里面的响应式实现</a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/vue-learn/assets/js/app.06b834f0.js" defer></script><script src="/vue-learn/assets/js/2.98137049.js" defer></script><script src="/vue-learn/assets/js/7.f958185c.js" defer></script>
  </body>
</html>
