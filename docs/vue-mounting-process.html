<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue的组件挂载 | vue-learn</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/vue-learn/assets/css/0.styles.d467352b.css" as="style"><link rel="preload" href="/vue-learn/assets/js/app.5c75693e.js" as="script"><link rel="preload" href="/vue-learn/assets/js/2.98137049.js" as="script"><link rel="preload" href="/vue-learn/assets/js/9.787f4597.js" as="script"><link rel="prefetch" href="/vue-learn/assets/js/10.dddda723.js"><link rel="prefetch" href="/vue-learn/assets/js/3.ae97eef9.js"><link rel="prefetch" href="/vue-learn/assets/js/4.a2975e0c.js"><link rel="prefetch" href="/vue-learn/assets/js/5.c90b2ea4.js"><link rel="prefetch" href="/vue-learn/assets/js/6.8be95152.js"><link rel="prefetch" href="/vue-learn/assets/js/7.b25d972c.js"><link rel="prefetch" href="/vue-learn/assets/js/8.a2e6ed3a.js">
    <link rel="stylesheet" href="/vue-learn/assets/css/0.styles.d467352b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vue-learn/" class="home-link router-link-active"><!----> <span class="site-name">vue-learn</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/vue-learn/" class="sidebar-link">快速理解Vue的响应式</a></li><li><a href="/vue-learn/vue-reactive-in-vue.html" class="sidebar-link">Vue里面的响应式实现</a></li><li><a href="/vue-learn/vue-compile-render.html" class="sidebar-link">Vue的组件编译</a></li><li><a href="/vue-learn/vue-mounting-process.html" class="active sidebar-link">Vue的组件挂载</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-learn/vue-mounting-process.html#挂载过程（mounting）" class="sidebar-link">挂载过程（mounting）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-learn/vue-mounting-process.html#_1-我们先回到最原始的-mount被调用的地方：" class="sidebar-link">1.我们先回到最原始的$mount被调用的地方：</a></li><li class="sidebar-sub-header"><a href="/vue-learn/vue-mounting-process.html#_2-mount的版本配置" class="sidebar-link">2 $mount的版本配置</a></li><li class="sidebar-sub-header"><a href="/vue-learn/vue-mounting-process.html#_3-模板-template）转化render" class="sidebar-link">3 模板(Template）转化render</a></li><li class="sidebar-sub-header"><a href="/vue-learn/vue-mounting-process.html#_4-compiletofunctions做了什么" class="sidebar-link">4 compileToFunctions做了什么</a></li><li class="sidebar-sub-header"><a href="/vue-learn/vue-mounting-process.html#_5回到mountcomponent" class="sidebar-link">5回到mountComponent</a></li><li class="sidebar-sub-header"><a href="/vue-learn/vue-mounting-process.html#_6-render又干了什么？" class="sidebar-link">6 _render又干了什么？</a></li><li class="sidebar-sub-header"><a href="/vue-learn/vue-mounting-process.html#_7-update-又做了什么？" class="sidebar-link">7_update()又做了什么？</a></li></ul></li><li class="sidebar-sub-header"><a href="/vue-learn/vue-mounting-process.html#关于patch的理解" class="sidebar-link">关于Patch的理解</a></li></ul></li><li><a href="/vue-learn/react-compare-vue.html" class="sidebar-link">React与Vue</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue的组件挂载"><a href="#vue的组件挂载" class="header-anchor">#</a> Vue的组件挂载</h1> <h2 id="挂载过程（mounting）"><a href="#挂载过程（mounting）" class="header-anchor">#</a> 挂载过程（mounting）</h2> <p>前面两篇文章中（响应式实现和组件编译）我们都特别提到了有一个很重要的函数：</p> <div class="language-js extra-class"><pre class="language-js"><code>vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span> 
</code></pre></div><p>这个函数里面我们之前提到了<code>vm._render()</code>干了什么，但是对于<code>vm._update</code>并没有详细说明，并且整体流程也不够详细，所以我们这次将会详细讲讲，整个组件挂载过程是什么样子的，并且这个核心函数到底干了什么。</p> <p>这个函数会在<code>mounting</code>的过程被调用，完整的函数是这个样子的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">mountComponent</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeMount'</span><span class="token punctuation">)</span>    
    <span class="token keyword">let</span> <span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span> 
    <span class="token punctuation">}</span>  
    <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> updateComponent<span class="token punctuation">,</span> noop<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token operator">...</span>
</code></pre></div><p>其中：</p> <ul><li><code>vm._render()</code>：Render函数--&gt;VNode</li> <li><code>vm._update()</code>：VNode--&gt;DOM</li></ul> <p>我们现在回过头来，从<code>$mount</code>开始，一点点看整个mount过程到底做了什么</p> <h3 id="_1-我们先回到最原始的-mount被调用的地方："><a href="#_1-我们先回到最原始的-mount被调用的地方：" class="header-anchor">#</a> 1.我们先回到最原始的<code>$mount</code>被调用的地方：</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// /src/core/instance/index.js</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">initMixin</span> <span class="token punctuation">(</span><span class="token parameter">Vue<span class="token punctuation">:</span> Class<span class="token operator">&lt;</span>Component<span class="token operator">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_init</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">options<span class="token operator">?</span><span class="token punctuation">:</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> vm<span class="token punctuation">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token operator">...</span>
    <span class="token function">initState</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
    <span class="token operator">...</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span>  
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在Vue组件初始化的时候，<code>$mount</code>被执行了，这里是整个<code>new Vue</code>的入口，但是<code>$mount</code>的定义是比较独特的，这与Vue本身的版本配置有关的。</p> <h3 id="_2-mount的版本配置"><a href="#_2-mount的版本配置" class="header-anchor">#</a> 2 <code>$mount</code>的版本配置</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// /scripts/config.js</span>
<span class="token keyword">const</span> builds <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// runtime-only build (Browser)</span>
  <span class="token string">&quot;web-runtime-dev&quot;</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
    entry<span class="token punctuation">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&quot;web/entry-runtime.js&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 这里的mount定义里只包含执行render函数部分</span>
    dest<span class="token punctuation">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&quot;dist/vue.runtime.js&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// Runtime+compiler development build (Browser)</span>
  <span class="token string">&quot;web-full-dev&quot;</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
    entry<span class="token punctuation">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&quot;web/entry-runtime-with-compiler.js&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 这里的mount包含Template转化为render函数并且执行render函数</span>
    dest<span class="token punctuation">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&quot;dist/vue.js&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>正如这段配置显示的，当我们使用不同版本的Vue的时候，执行的代码也会有所不同，这也是我在上一篇文章中提到的</p> <blockquote><p>如果是Runtime+compiler版本的$mount，那么mount方法会被执行两次，一次转化模板，一次执行render函数</p></blockquote> <p>这一段话的原因所在。本质上<code>Runtime+compiler</code>版本是多执行了一段模板转化代码，所以我们先看这段模板转化做了什么</p> <h3 id="_3-模板-template）转化render"><a href="#_3-模板-template）转化render" class="header-anchor">#</a> 3 模板(Template）转化render</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// /src/platforms/web/entry-runtime-with-compiler.js</span>

    <span class="token keyword">const</span> mount <span class="token operator">=</span> <span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$mount <span class="token comment">// 这个$mount定义在/src/platforms/web/runtime/index.js里面，只执行render渲染之后的操作</span>
    <span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$mount</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">el<span class="token operator">?</span><span class="token punctuation">:</span> string <span class="token operator">|</span> Element<span class="token punctuation">,</span> hydrating<span class="token operator">?</span><span class="token punctuation">:</span> boolean</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Component <span class="token punctuation">{</span>
      el <span class="token operator">=</span> el <span class="token operator">&amp;&amp;</span> <span class="token function">query</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
      <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$options
      
      <span class="token comment">// 只有在没有render函数的时候，才需要将template转化为render</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>options<span class="token punctuation">.</span>render<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> template <span class="token operator">=</span> options<span class="token punctuation">.</span>template
        <span class="token keyword">if</span> <span class="token punctuation">(</span>template<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 真正转化template的地方</span>
          <span class="token keyword">const</span> <span class="token punctuation">{</span> render<span class="token punctuation">,</span> staticRenderFns <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">compileToFunctions</span><span class="token punctuation">(</span>template<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token operator">...</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
          options<span class="token punctuation">.</span>render <span class="token operator">=</span> render  <span class="token comment">// 现在我们得到了所要的render函数</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 执行之前拿到的mount函数（/runtime/index.js版本）</span>
      <span class="token keyword">return</span> <span class="token function">mount</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> el<span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>这里需要注意的就是<code>$mount</code>是被重新定义了的，所以在<code>Runtime+compiler</code>版本中的代码，执行了两次<code>mount</code></p> <ul><li>第一次：定义在<code>/src/platforms/web/entry-runtime-with-compiler.js</code>里面，核心方法是<code>compileToFunctions</code>，主要逻辑就是把<code>template</code>转为我们需要的<code>render</code>函数</li> <li>第二次：定义在<code>/src/platforms/web/runtime/index.js</code>里面，核心方法是<code>mountComponent</code>（就是我们一开始提到的这个函数）主要逻辑就是执行Render的渲染和DOM的更新。具体细节我们在之后会看到</li></ul> <h3 id="_4-compiletofunctions做了什么"><a href="#_4-compiletofunctions做了什么" class="header-anchor">#</a> 4 <code>compileToFunctions</code>做了什么</h3> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token keyword">from</span><span class="token punctuation">:</span> template<span class="token punctuation">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;h1&gt;{{ this.name }}&lt;/h1&gt;</span><span class="token template-punctuation string">`</span></span>
 
 to<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token function">_v</span><span class="token punctuation">(</span><span class="token function">_s</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
</code></pre></div><p><code>compileToFunctions</code>这个方法就是把template模板转化为了这个看起来又长又难懂的函数，注意在这个地方，这个函数访问了<code>this.name</code>，这也是我们为什么<code>render</code>函数能够触发响应式数据的<code>dep.depend</code>的原因，里面有一些带下划线的函数简写，这些是定义在</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// /src/core/instance/render-helpers.js</span>

target<span class="token punctuation">.</span>_o <span class="token operator">=</span> markOnce
target<span class="token punctuation">.</span>_n <span class="token operator">=</span> toNumber
target<span class="token punctuation">.</span>_s <span class="token operator">=</span> toString <span class="token comment">// &lt;-------</span>
target<span class="token punctuation">.</span>_l <span class="token operator">=</span> renderList
target<span class="token punctuation">.</span>_t <span class="token operator">=</span> renderSlot
target<span class="token punctuation">.</span>_q <span class="token operator">=</span> looseEqual
target<span class="token punctuation">.</span>_i <span class="token operator">=</span> looseIndexOf
target<span class="token punctuation">.</span>_m <span class="token operator">=</span> renderStatic
target<span class="token punctuation">.</span>_f <span class="token operator">=</span> resolveFilter
target<span class="token punctuation">.</span>_k <span class="token operator">=</span> checkKeyCodes
target<span class="token punctuation">.</span>_b <span class="token operator">=</span> bindObjectProps
target<span class="token punctuation">.</span>_v <span class="token operator">=</span> createTextVNode <span class="token comment">// &lt;------</span>
target<span class="token punctuation">.</span>_e <span class="token operator">=</span> createEmptyVNode
target<span class="token punctuation">.</span>_u <span class="token operator">=</span> resolveScopedSlots
target<span class="token punctuation">.</span>_g <span class="token operator">=</span> bindObjectListeners

</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// /src/core/vdom/vnode.js</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createTextVNode</span> <span class="token punctuation">(</span><span class="token parameter">val<span class="token punctuation">:</span> string <span class="token operator">|</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">VNode</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token function">String</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这些函数就是一些有关于Vnode的操作，Render函数执行完最终返回的就是一个Vnode。</p> <h3 id="_5回到mountcomponent"><a href="#_5回到mountcomponent" class="header-anchor">#</a> 5回到<code>mountComponent</code></h3> <p>当我们执行完<code>compileToFunctions</code>之后，就执行完第一次的mount，接下来我们就执行第二次的mount，</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// /src/platforms/web/runtime.js</span>
    <span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$mount</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>
      <span class="token parameter">el<span class="token operator">?</span><span class="token punctuation">:</span> string <span class="token operator">|</span> Element<span class="token punctuation">,</span>
      hydrating<span class="token operator">?</span><span class="token punctuation">:</span> boolean</span>
    <span class="token punctuation">)</span><span class="token punctuation">:</span> Component <span class="token punctuation">{</span>
      el <span class="token operator">=</span> el <span class="token operator">&amp;&amp;</span> inBrowser <span class="token operator">?</span> <span class="token function">query</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">undefined</span> <span class="token comment">// 获取或者补充一个必备的dom</span>
      <span class="token keyword">return</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> el<span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span> <span class="token comment">// &lt;-- 这里就执行了mountComponent方法</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>我们接下来看一下<code>mountComponent</code>干了什么：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// /src/core/instance/lifecycle.js   </span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">mountComponent</span> <span class="token punctuation">(</span>
      <span class="token parameter">vm<span class="token punctuation">:</span> Component<span class="token punctuation">,</span>
      el<span class="token punctuation">:</span> <span class="token operator">?</span>Element<span class="token punctuation">,</span>
      hydrating<span class="token operator">?</span><span class="token punctuation">:</span> boolean</span>
    <span class="token punctuation">)</span><span class="token punctuation">:</span> Component <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> el
      <span class="token operator">...</span>
      <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeMount'</span><span class="token punctuation">)</span> 
      
      <span class="token keyword">let</span> updateComponent
      <span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>							<span class="token comment">//数据更新的核心方法</span>
      <span class="token punctuation">}</span>
    
      <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> updateComponent<span class="token punctuation">,</span> noop<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* isRenderWatcher */</span><span class="token punctuation">)</span>
      
      hydrating <span class="token operator">=</span> <span class="token boolean">false</span>
      <span class="token keyword">return</span> vm
 <span class="token punctuation">}</span>
</code></pre></div><p>还记得我们的<a href="/vue-learn/reactive-in-vue.html">Vue的响应式实现</a>文章中提到的</p> <blockquote><p>updateComponent：计算函数，用来计算组件内各个数据的值，每次Vue的数据变化，其实就是需要重新触发这个函数的计算，从而实现响应式的数据更新</p></blockquote> <p>的这一段话么，我们的<code>Render Watcher</code>的重新计算函数就是<code>updateComponent</code>，所以这个函数会被频繁触发，每次数据有修改都会被执行一次。也就是会多次执行<code>vm._update</code>和<code>vm._render</code></p> <h3 id="_6-render又干了什么？"><a href="#_6-render又干了什么？" class="header-anchor">#</a> 6 <code>_render</code>又干了什么？</h3> <p>所以我们现在知道了<code>_render</code>会多次执行，那我们看看它内部又做了些什么：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// /src/core/instance/render.js</span>
    <span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_render</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> VNode <span class="token punctuation">{</span>
        <span class="token keyword">const</span> vm<span class="token punctuation">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span>
        <span class="token keyword">const</span> <span class="token punctuation">{</span> render<span class="token punctuation">,</span> _parentVnode <span class="token punctuation">}</span> <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options
        
        <span class="token comment">//添加parentVnode，提供在render函数中的vnode的上级寻找访问</span>
        vm<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> _parentVnode
        <span class="token comment">// render self</span>
        <span class="token keyword">let</span> vnode
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
          vnode <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_renderProxy<span class="token punctuation">,</span> vm<span class="token punctuation">.</span>$createElement<span class="token punctuation">)</span> <span class="token comment">// &lt;--- 执行了我们的Render函数，返回一个Vnode</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
    
        <span class="token comment">// set parent    </span>
        vnode<span class="token punctuation">.</span>parent <span class="token operator">=</span> _parentVnode
        <span class="token keyword">return</span> vnode
      <span class="token punctuation">}</span>
</code></pre></div><p>所以在这里的核心其实就是执行了<code>render.call</code>也就是执行了我们得到的render函数，对应我们之前的例子，就是执行了</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">with</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token function">_v</span><span class="token punctuation">(</span><span class="token function">_s</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>这么一个函数。然后返回了了一个Vnode。接着拿着这个Vnode渲染为我们真实的DOM</p> <h3 id="_7-update-又做了什么？"><a href="#_7-update-又做了什么？" class="header-anchor">#</a> 7<code>_update()</code>又做了什么？</h3> <p>我们现在继续看看<code>_update</code>是怎么把<code>Vnode</code>转化为我们需要的DOM节点。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// /src/core/instance/lifecycle.js   </span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_update</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">:</span> VNode<span class="token punctuation">,</span> hydrating<span class="token operator">?</span><span class="token punctuation">:</span> boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> vm<span class="token punctuation">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_isMounted<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 如果我们已经把对应的Vnode渲染到了DOM上</span>
          <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeUpdate'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        
        <span class="token keyword">const</span> prevVnode <span class="token operator">=</span> vm<span class="token punctuation">.</span>_vnode <span class="token comment">// 保存原始的Vnode</span>
    
        vm<span class="token punctuation">.</span>_vnode <span class="token operator">=</span> vnode <span class="token comment">// 保存当前的vnode到对应的VM内，用于patch函数</span>
    
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prevVnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 如果没有以前的VNode，那么创建并插入DOM节点</span>
          vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">__patch__</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$el<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> hydrating<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>_parentElm<span class="token punctuation">,</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>_refElm<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token comment">// 更新发生在这里。注意，我们正在发送prevVnode和新节点，以便最少的DOM更新发生。</span>
          vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">__patch__</span><span class="token punctuation">(</span>prevVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
</code></pre></div><p>所以这里我们注意到，下一步就要执行<code>__patch__</code>，这其实是个对比diff算法，定义在</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// /src/platforms/web/runtime/index.js</span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__patch__ <span class="token operator">=</span> inBrowser <span class="token operator">?</span> patch <span class="token punctuation">:</span> noop
</code></pre></div><p>这里我们需要注意一下，这个patch方法，只有在浏览器环境下才有，其他环境是不存在这个函数的（因为其他环境不存在DOM），我们看一下关于patch方法的定义</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// /src/platforms/web/runtime/patch.js</span>
<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> nodeOps <span class="token keyword">from</span> <span class="token string">'web/runtime/node-ops'</span>
<span class="token operator">...</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> patch<span class="token punctuation">:</span> Function <span class="token operator">=</span> <span class="token function">createPatchFunction</span><span class="token punctuation">(</span><span class="token punctuation">{</span> nodeOps<span class="token punctuation">,</span> modules <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// /src/core/vdom/patch.js</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createPatchFunction</span> <span class="token punctuation">(</span><span class="token parameter">backend</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 	  <span class="token keyword">const</span> <span class="token punctuation">{</span> modules<span class="token punctuation">,</span> nodeOps <span class="token punctuation">}</span> <span class="token operator">=</span> backend 
    <span class="token operator">...</span>
		vnode<span class="token punctuation">.</span>elm <span class="token operator">=</span> nodeOps<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
  	<span class="token operator">...</span>
    vnode<span class="token punctuation">.</span>elm <span class="token operator">=</span> nodeOps<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// /src/platforms/web/runtime/node-ops.js</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tagName<span class="token punctuation">:</span> string<span class="token punctuation">,</span> vnode<span class="token punctuation">:</span> VNode</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Element <span class="token punctuation">{</span>
  <span class="token keyword">const</span> elm <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>tagName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token parameter">text<span class="token punctuation">:</span> string</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Text <span class="token punctuation">{</span>
  <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里面我省略了不少内容，主要是<code>createPatchFunction</code>是怎么转化处理各种Vnode节点的，当数据更新的时候会有四个步骤来处理DOM的更新</p> <ul><li>对比新旧VNode是否一致，不一致继续往下走</li> <li>创建新节点</li> <li>更新父的占位符节点</li> <li>删除旧节点</li></ul> <p>而处理DOM相关的时候也会用到比如 <code>createElement</code>，<code>createTextNode</code>这样的方法，而这些方法我们看到，本质上就是真实的DOM操作。从而就真正的触及到了DOM操作</p> <h2 id="关于patch的理解"><a href="#关于patch的理解" class="header-anchor">#</a> 关于Patch的理解</h2> <p>当我们这个时候返回来看这个<code>patch.js</code>文件的时候，会发现比较有意思的一点，当我们配置的<code>config.js</code>的版本是不同的时候，其实<code>patch.js</code>的代码几乎是一样的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// /src/platforms/web/runtime/patch.js</span>
<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> nodeOps <span class="token keyword">from</span> <span class="token string">'web/runtime/node-ops'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> createPatchFunction <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'core/vdom/patch'</span>
<span class="token keyword">import</span> baseModules <span class="token keyword">from</span> <span class="token string">'core/vdom/modules/index'</span>
<span class="token keyword">import</span> platformModules <span class="token keyword">from</span> <span class="token string">'web/runtime/modules/index'</span>

<span class="token comment">// the directive module should be applied last, after all</span>
<span class="token comment">// built-in modules have been applied.</span>
<span class="token keyword">const</span> modules <span class="token operator">=</span> platformModules<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>baseModules<span class="token punctuation">)</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> patch<span class="token punctuation">:</span> Function <span class="token operator">=</span> <span class="token function">createPatchFunction</span><span class="token punctuation">(</span><span class="token punctuation">{</span> nodeOps<span class="token punctuation">,</span> modules <span class="token punctuation">}</span><span class="token punctuation">)</span>


<span class="token comment">// /src/platforms/weex/runtime/patch.js</span>
<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> nodeOps <span class="token keyword">from</span> <span class="token string">'weex/runtime/node-ops'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> createPatchFunction <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'core/vdom/patch'</span>
<span class="token keyword">import</span> baseModules <span class="token keyword">from</span> <span class="token string">'core/vdom/modules/index'</span>
<span class="token keyword">import</span> platformModules <span class="token keyword">from</span> <span class="token string">'weex/runtime/modules/index'</span>

<span class="token comment">// the directive module should be applied last, after all</span>
<span class="token comment">// built-in modules have been applied.</span>
<span class="token keyword">const</span> modules <span class="token operator">=</span> platformModules<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>baseModules<span class="token punctuation">)</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> patch<span class="token punctuation">:</span> Function <span class="token operator">=</span> <span class="token function">createPatchFunction</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  nodeOps<span class="token punctuation">,</span>
  modules<span class="token punctuation">,</span>
  <span class="token constant">LONG_LIST_THRESHOLD</span><span class="token punctuation">:</span> <span class="token number">10</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div><p>仔细看这两个<code>web</code>版本和<code>weex</code>版本的差异，其实就是<code>nodeOps</code>和<code>modules</code>两个文件的来源不同，分别都是各自的平台。</p> <ul><li><code>nodeOps</code>：提供对应平台的操作函数中转，对于web平台就是DOM操作，对于Weex平台就是Weex DOM操作，但是在上层统一了操作API名字</li> <li><code>modules</code>：提供对应平台的diff算法，找到不同平台的Vnode差异。使用nodeOps里面提供的函数，diff处理Vnode的数据差异导致的UI更新（web上的是操作DOM，Weex上操作Weex Dom）</li></ul> <p>最终再通过<code>createPatchFunction</code>函数把节点差异更新到UI层级上（新增节点，插入节点，删除节点）</p> <p>所以当我们深入的了解了<code>Patch</code>究竟在做什么的时候，其实我们就可以知道<code>Vue</code>本身不只是一个前端框架，而是可以看作为一个响应式数据的编译器，通过<code>Vue</code>来编译成<code>Vnode</code>，但是Vnode--&gt;DOM的编译只是是因为<code>Vue</code>本身提供了<code>Web</code>浏览器平台的<code>patch</code>处理，提供了<code>Weex</code>平台<code>patch</code>的时候，就可以处理Vnode--&gt;Weex DOM，当我们提供更多其他平台的patch的时候，就可以在其他的平台上执行，比如iOS，Android等等（当然现在这两个平台我们都用Weex解决了）</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vue-learn/vue-compile-render.html" class="prev">Vue的组件编译</a></span> <span class="next"><a href="/vue-learn/react-compare-vue.html">React与Vue</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/vue-learn/assets/js/app.5c75693e.js" defer></script><script src="/vue-learn/assets/js/2.98137049.js" defer></script><script src="/vue-learn/assets/js/9.787f4597.js" defer></script>
  </body>
</html>
