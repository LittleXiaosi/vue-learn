<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React与Vue | vue-learn</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/vue-learn/assets/css/0.styles.d467352b.css" as="style"><link rel="preload" href="/vue-learn/assets/js/app.5c75693e.js" as="script"><link rel="preload" href="/vue-learn/assets/js/2.98137049.js" as="script"><link rel="preload" href="/vue-learn/assets/js/7.b25d972c.js" as="script"><link rel="prefetch" href="/vue-learn/assets/js/10.dddda723.js"><link rel="prefetch" href="/vue-learn/assets/js/3.ae97eef9.js"><link rel="prefetch" href="/vue-learn/assets/js/4.a2975e0c.js"><link rel="prefetch" href="/vue-learn/assets/js/5.c90b2ea4.js"><link rel="prefetch" href="/vue-learn/assets/js/6.8be95152.js"><link rel="prefetch" href="/vue-learn/assets/js/8.a2e6ed3a.js"><link rel="prefetch" href="/vue-learn/assets/js/9.787f4597.js">
    <link rel="stylesheet" href="/vue-learn/assets/css/0.styles.d467352b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vue-learn/" class="home-link router-link-active"><!----> <span class="site-name">vue-learn</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/vue-learn/" class="sidebar-link">快速理解Vue的响应式</a></li><li><a href="/vue-learn/vue-reactive-in-vue.html" class="sidebar-link">Vue里面的响应式实现</a></li><li><a href="/vue-learn/vue-compile-render.html" class="sidebar-link">Vue的组件编译</a></li><li><a href="/vue-learn/vue-mounting-process.html" class="sidebar-link">Vue的组件挂载</a></li><li><a href="/vue-learn/react-compare-vue.html" class="active sidebar-link">React与Vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-learn/react-compare-vue.html#初步了解react的各种概念" class="sidebar-link">初步了解React的各种概念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-learn/react-compare-vue.html#jsx" class="sidebar-link">JSX</a></li><li class="sidebar-sub-header"><a href="/vue-learn/react-compare-vue.html#元素渲染" class="sidebar-link">元素渲染</a></li><li class="sidebar-sub-header"><a href="/vue-learn/react-compare-vue.html#组件与props" class="sidebar-link">组件与Props</a></li><li class="sidebar-sub-header"><a href="/vue-learn/react-compare-vue.html#state与生命周期" class="sidebar-link">State与生命周期</a></li><li class="sidebar-sub-header"><a href="/vue-learn/react-compare-vue.html#事件处理" class="sidebar-link">事件处理</a></li><li class="sidebar-sub-header"><a href="/vue-learn/react-compare-vue.html#条件渲染，列表-key" class="sidebar-link">条件渲染，列表&amp;key</a></li><li class="sidebar-sub-header"><a href="/vue-learn/react-compare-vue.html#表单" class="sidebar-link">表单</a></li><li class="sidebar-sub-header"><a href="/vue-learn/react-compare-vue.html#状态提升" class="sidebar-link">状态提升</a></li><li class="sidebar-sub-header"><a href="/vue-learn/react-compare-vue.html#组合与继承" class="sidebar-link">组合与继承</a></li></ul></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react与vue"><a href="#react与vue" class="header-anchor">#</a> React与Vue</h1> <h2 id="初步了解react的各种概念"><a href="#初步了解react的各种概念" class="header-anchor">#</a> 初步了解React的各种概念</h2> <h3 id="jsx"><a href="#jsx" class="header-anchor">#</a> JSX</h3> <p>React的JSX与Vue中的Template的概念是比较类似的，写法上会有一些差异，</p> <ol><li>Vue中快速取值使用<code>{{}}</code> 而在React中则是<code>{}</code>。</li> <li>命名规范，Vue中的Template属性会与Html保持一致，但是React使用了驼峰命名，更接近于JS语法</li> <li>创建节点，Vue的createElement与React的基本类似，传递的参数也是比较类似</li> <li>但是这里面有个区别就是一般来讲，Vue是不会强调JSX这个概念（虽然Vue也需要用到，Vue的Template会尽可能的贴近原生HTML体验，只有在写函数式组件，并且不直接引用.Vue文件的时候才需要这么写）</li></ol> <h3 id="元素渲染"><a href="#元素渲染" class="header-anchor">#</a> 元素渲染</h3> <ol><li>React使用<code>ReactDOM.render</code>函数来进行渲染，而Vue使用<code>new Vue</code>来进行渲染；</li> <li>React的元素渲染本身不是响应式，Vue本身的元素渲染就已经是响应式了。</li></ol> <h3 id="组件与props"><a href="#组件与props" class="header-anchor">#</a> 组件与Props</h3> <ol><li>React的函数式组件返回的是一个React元素，使用的是JSX语法定义。但是Vue的函数式组件返回的是一个Vnode节点（虚拟节点），这个节点其实是一个包含对Dom节点描述信息的JS对象。使用的是JS的语法。</li> <li>函数式组件定义中，React会将所有接收到的属性都封装在一个对象中作为prop传递，但是Vue只会接受定义了的prop，如果传递了未定义的props，在组件内部是获取不到这个参数的。并且在Vue中，props的名字定义是有保留字段的，即Vue本身的保留字段和HTML的特殊属性，比如class属性，就必须是一个<code>{className:boolean}</code>形态的对象</li> <li>组件大小写，React会通过组件大小写来区分是不是自定义组件，但是Vue只是通过是否自定义来区分，自定义的组件名称没有严格的格式要求，通常有大小写区分和横线区分两种。</li> <li>在Vue中，函数式组件只是因为这个组件需要通过一个特定函数来初始化，返回Vnode，但是React中，任何一个返回React 元素（JSX语法）的函数，都是一个组件。</li> <li>Props，在Vue中，Props必须有明确的定义，包括字段名称和字段类型，在统一位置处理props输入（目前V2.x版本），但是React并没有需要严格校验Props，Props的管理与JS类似，是一种松散的JS对象式管理（<u>所以这里会有一个潜在问题，大量的Props需要怎么管理？,多级JSX参数需要知道上一级数据结构，需要怎么管理？因为当前组件的数据来源是上一级组件的数据封装，额外封装的时候怎么知道属性格式？</u>）</li> <li>Props修改，React不允许修改Props，Vue的Props也是不允许修改的，这是一致的，Vue只允许修改组件内的Data，Props只能接受参数</li></ol> <h3 id="state与生命周期"><a href="#state与生命周期" class="header-anchor">#</a> State与生命周期</h3> <ol><li>React与Vue在生命周期的核心概念上，差别就在于State和Data的概念，也是Vue的核心——响应式数据的原理。Vue是在数据内部通过给所有数据执行<strong>defineProperty</strong>，监控所有数据的set和get，从而达到自动检测数据的目的，Vue的核心引擎处理两部分，一部分是响应式数据，一部分是Vnode渲染为DOM。而React通过区分props和state，用来区分传参和内部数据，自行处理数据更新，React的核心引擎是处理JSX渲染为DOM这么一个过程。</li> <li>Vue的<code>$set</code>与React的<code>setState</code>，两者都是设置数据更新，但是<code>$set</code>主要是用来处理响应式数据增加<code>defineProperty</code>，React直接修改数据是不触发重新渲染的，但是Vue是可能触发重新渲染的。<code>$set</code>在Vue中算是一个辅助算法，但是<code>setState</code>在React中是一个必备方法</li> <li>相对而言，React的生命周期是比较短，易于理解的<a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener noreferrer">http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，但是Vue的生命周期因为涉及到数据更新和template部分，所以会复杂一些：<a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA" target="_blank" rel="noopener noreferrer">https://cn.vuejs.org/v2/guide/instance.html#生命周期图示<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>&gt;</li> <li>重新渲染这一部分，都是设计虚拟dom需要重新生成，这个阶段，React是通过<code>setState</code>来重新触发<code>render</code>函数，这个<code>render</code>函数对于React的使用者是自己编写的组件渲染代码，但是Vue是通过一个渲染<code>watcher</code>（render watcher）这个渲染<code>watcher</code>对于每一个组件都是默认生成的，对于使用者是不可见的黑盒，也不能操控。在这一点上，会导致使用Vue和React有比较大的感受差异。</li> <li>基于Vue的核心理念是数据驱动，所以要触发重新渲染，只能是数据有改变才行，但是对于React，还有<strong>forceUpdate</strong>可以触发强制渲染。</li> <li>数据更新，React的<code>setState</code>，其实不是同步更新数据，<code>setState</code>需要通过函数式设定，来获取上一次<code>setState</code>的返回值，而Vue的话，数据更新直接交给了响应式数据处理，所以数据更新部分是同步的，只是触发渲染部分再做了额外优化，不是同步渲染。</li> <li>Vue有一个React没有的概念，Computed，计算过的值，因为Vue的数据计算都是自动触发，所以在监听数据变化的时候，有缓存效率会比较高，Computed得到的就是基于响应式数据计算返回的数据，如果相关数据都不变的话，计算结果也就不会变的，这种时候，这个数据就没必要重新计算了，但是在React，数据计算需要在render中重新处理，所以不存在相关概念。</li></ol> <h3 id="事件处理"><a href="#事件处理" class="header-anchor">#</a> 事件处理</h3> <ol><li>对于JSX的处理上，React不会额外处理this指针的相关问题，所以在JSX上面执行函数的时候，就没有了对应的上下文环境了（也是是this指针指向的不是当前组件）这个时候就需要自行绑定this指向，但是在Vue上面，是不需要额外处理this问题，所有在组件内定义的data，prop和methods当前上下文环境都会改为当前组件。不需要考虑this指针变化问题。</li> <li>JSX的语法中，事件绑定和属性绑定是没有区别的，只是在绑定的属性上是不一致的，但是在Vue的语法中，绑定method和绑定data是不同的绑定方式，能够从template的中直接看出来。</li></ol> <h3 id="条件渲染，列表-key"><a href="#条件渲染，列表-key" class="header-anchor">#</a> 条件渲染，列表&amp;key</h3> <ol><li>在React中，是直接使用jsx语法来返回不同的React元素控制渲染，但是在Vue中，需要通过指令来控制渲染 ，不能直接操作Vue的Template元素部分。</li> <li>在列表渲染的时候，React通常使用Map方法来生成新的React元素，但是Vue更多是通过foreach方法，修改本来的元素，这样是个响应式变化。</li> <li>在列表渲染的时候，React使用index作为key值，是会影响到当数组数据变化时候的状态的，因为渲染的过程是手动的，可能会出现数据与渲染不同步的情况，但是Vue因为不是直接渲染，index作为key值，并不会有多大的影响，只是需要重新计算一次缓存，因为Vue是不能直接渲染的，想要变化UI，必须变化数据，在变化数据的时候是不会出现渲染与数据不同步的情况。</li> <li>React的JSX是可以嵌套js表达式的，也就是说内部可以包含比较复杂的逻辑，Vue是只允许通过既定的指令（当然指令也可以自定义）来处理渲染层面的问题，Vue在Template的层级复杂度，基本取决于Dom结构的层级，和逻辑关系不大，逻辑会放在script部分单独处理</li></ol> <h3 id="表单"><a href="#表单" class="header-anchor">#</a> 表单</h3> <ol><li>在Vue中，主要通过双向绑定的v-model来处理数据输入输出，这个语法糖会针对当前的DOM类型，内部已经处理了需要绑定的事件，因为使用方法用语法糖包装，所以表现形式是一致的，本质上Vue的所有表单组件，都是React概念里的“受控组件”。React的表单组件事件部分需要自行封装，事件表现每个表单控件是不一致的。但是React有一个推荐的解决方案<a href="https://jaredpalmer.com/formik/docs/overview" target="_blank" rel="noopener noreferrer">https://jaredpalmer.com/formik/docs/overview<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>来处理表单数据收集以及验证的问题。</li> <li>Vue本身只是提供了一个v-model的语法糖来处理输入输出的问题，但是并不提供验证相关的内容，只是可以添加修饰符来限制输入，因为数据是同步提供的，大多数情况下是组件库底层封装额外的验证处理</li></ol> <h3 id="状态提升"><a href="#状态提升" class="header-anchor">#</a> 状态提升</h3> <ol><li>在Vue内，其实没有“状态提升”这么个概念，因为每个Data都是自己的，如果需要使用到上层数据，通常就是通过事件触发修改，或者使用继承数据（但是这是个非响应式数据，使用的比较少）。而因为v-model的封装，有时候也通过v-model解决。而React其实也是这个类似的处理方法，把state放在上级组件中的state管理，通过事件更新数据。</li> <li>React开发着工具与Vue开发者工具类似，都是可以拿来看当前组件参数，用于定位bug。但是Vue工具会相对复杂一点，还包含事件的监测。</li></ol> <h3 id="组合与继承"><a href="#组合与继承" class="header-anchor">#</a> 组合与继承</h3> <ol><li>“作用域插槽”这在Vue中是一个比较重要的概念，因为Vue的Prop传递是不能传递组件本身的。只能是js的数据类型，所以在这个时候，如果是动态组件的话，除了使用函数组件以外，另一种方式就是使用作用域插槽（slot）来处理，即“把Vue组件作为参数传递”，而React的jsx语法是没有这个限制的，props可以传递任何东西（jsx的解析器确实牛逼），所以props本身就可以传递组件，就可以作为slot来传递，没有额外限制。</li> <li>“继承”的概念在React内比较少出现，比较常见的是组件需要继承于<code>React.Component</code>，本身组件相互之间都是引用(import)，很少使用继承的概念，这点和Vue很类似，所有组件都是平级的，都是可以相互引用的，子组件的概念都是人为规定的，从语法上，并没有严格的父子组件的规定。（所以出现递归引用也是可能的）。</li> <li></li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vue-learn/vue-mounting-process.html" class="prev">Vue的组件挂载</a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/vue-learn/assets/js/app.5c75693e.js" defer></script><script src="/vue-learn/assets/js/2.98137049.js" defer></script><script src="/vue-learn/assets/js/7.b25d972c.js" defer></script>
  </body>
</html>
